<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Just Divide — Full</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.min.js"></script>
  <style>
    html,body { height:100%; margin:0; background:#fbe8e8; }
    #game-container { width:100%; height:100%; display:flex; align-items:center; justify-content:center; }
  </style>
</head>
<body>
  <div id="game-container"></div>

<script>
// --------------------------- Configuration ---------------------------
const DESIGN = { width:1440, height:1024 };
const TILE_COLORS = ['blue','red','purple','orange','pink']; // asset keys suffixes
const START_TRASH = 10;
const POINTS_PER_DIVIDE_BASE = 10;
const LEVEL_SCORE_STEP = 10; // every 10 points -> level up

// Utility: random tile value generator (choose from typical divisors/multiples)
function randomTileValue(level) {
  // level affects max base value
  const maxBase = 8 + level * 2; // increases with level
  const pool = [];
  // produce a mix of multiples that produce interesting divisions
  for (let n = 2; n <= Math.min(30, maxBase + 8); n++) pool.push(n);
  return pool[Phaser.Math.Between(0, pool.length-1)];
}

// --------------------------- Phaser Scenes ---------------------------
class BootScene extends Phaser.Scene {
  constructor() { super('BootScene'); }
  preload() {
    // Try to load your asset filenames (case-sensitive)
    this.load.image('bg', 'assets/Landscape_JustDivide_Game_2.png');
    this.load.image('cat', 'assets/Cat.png');
    this.load.image('levelScore', 'assets/Levels and Score.png');
    this.load.image('gridPanel', 'assets/Placement_Box.png');
    // tile images
    this.load.image('tile_blue', 'assets/blue.png');
    this.load.image('tile_red', 'assets/red.png');
    this.load.image('tile_purple', 'assets/purple.png');
    this.load.image('tile_orange', 'assets/orange.png');
    this.load.image('tile_pink', 'assets/pink.png');

    // optional assets may fail silently; fallback handled in GameScene

    // tiny loader text
    const w = this.cameras.main.width, h = this.cameras.main.height;
    const loading = this.add.text(w/2, h/2, 'Loading...', { fontSize:'18px', color:'#444' }).setOrigin(0.5);
    this.load.on('complete', () => {
      this.time.delayedCall(120, ()=> this.scene.start('GameScene'));
    });
  }
}

class GameScene extends Phaser.Scene {
  constructor() {
    super('GameScene');
    // game state
    this.grid = new Array(16).fill(null); // 4x4
    this.queue = [];
    this.keepVal = null;
    this.score = 0;
    this.best = parseInt(localStorage.getItem('jd_best')||'0',10);
    this.level = 1;
    this.trash = START_TRASH;
    this.undoStack = []; // optional future
  }

  create() {
    const W = this.scale.width, H = this.scale.height;

    // Background (use image if loaded, else rectangle)
    if (this.textures.exists('bg')) {
      this.add.image(W/2, H/2, 'bg').setDisplaySize(W, H);
    } else {
      this.add.rectangle(W/2, H/2, W, H, 0xffefe8);
    }

    // Header Title
    this.add.text(W/2, 50, 'JUST DIVIDE', { font: '48px Arial', fontStyle: 'bold', color:'#000' }).setOrigin(0.5);
    this.add.text(W/2, 100, 'DIVIDE WITH THE NUMBERS TO SOLVE THE ROWS AND COLUMNS.', { font:'20px Arial', color:'#b63636' }).setOrigin(0.5);

    // Cat and level-score panel (use loaded images or fallbacks)
    if (this.textures.exists('cat')) {
      this.add.image(W/2, 200, 'cat').setScale(0.75).setOrigin(0.5);
    }
    // level & score image if exists
    if (this.textures.exists('levelScore')) {
      this.add.image(W/2, 300, 'levelScore').setScale(0.9).setOrigin(0.5);
    } else {
      // fallback: draw two rounded boxes
      const left = this.add.rectangle(W/2 - 120, 300, 220, 80, 0xd9534f).setOrigin(0.5).setStrokeStyle(4, 0xffffff);
      const right = this.add.rectangle(W/2 + 120, 300, 220, 80, 0xd9534f).setOrigin(0.5).setStrokeStyle(4, 0xffffff);
    }
    // HUD text over the badges
    this.levelText = this.add.text(W/2 - 120, 300, `LEVEL ${this.level}`, { font:'28px Arial', color:'#fff', fontStyle:'bold' }).setOrigin(0.5);
    this.scoreText = this.add.text(W/2 + 120, 300, `SCORE ${this.score}`, { font:'28px Arial', color:'#fff', fontStyle:'bold' }).setOrigin(0.5);
    this.bestText = this.add.text(W/2 + 120, 333, `Best: ${this.best}`, { font:'16px Arial', color:'#fff' }).setOrigin(0.5);

    // Grid panel (use image if available)
    const gridCenterX = W*0.35, gridCenterY = H*0.60;
    if (this.textures.exists('gridPanel')) {
      this.add.image(gridCenterX, gridCenterY, 'gridPanel').setScale(1.0);
    } else {
      // faint background rectangle
      this.add.rectangle(gridCenterX, gridCenterY, 560, 560, 0xe3ffff).setStrokeStyle(6,0x99e6e6);
    }

    // Build 4x4 slots (store positions)
    this.slotPositions = [];
    const slotSize = 110;
    const spacing = 130;
    const topLeftX = gridCenterX - (1.5 * spacing);
    const topLeftY = gridCenterY - (1.5 * spacing);

    for (let r=0;r<4;r++){
      for (let c=0;c<4;c++){
        const x = topLeftX + c*spacing;
        const y = topLeftY + r*spacing;
        // slot background style identical to PDF: turquoise box with white border
        const slotBg = this.add.rectangle(x, y, slotSize, slotSize, 0x007a92).setStrokeStyle(6, 0xffffff).setOrigin(0.5);
        this.slotPositions.push({ x, y, r, c, index: r*4 + c });
      }
    }

    // Right-side vertical action panel (KEEP, UPCOMING, TRASH)
    const panelX = W*0.82;
    // KEEP label & slot
    this.add.text(panelX, 240, 'KEEP', { font:'24px Arial', color:'#000' }).setOrigin(0.5);
    // keep slot graphic
    this.keepSlotBox = this.add.rectangle(panelX, 320, 110, 110, 0xffffff).setStrokeStyle(6, 0x9fe2ff).setOrigin(0.5);
    // upcoming label
    this.add.text(panelX, 420, 'UPCOMING', { font:'22px Arial', color:'#000' }).setOrigin(0.5);
    // upcoming placeholders (stack 3)
    this.upcomingSprites = [];
    for (let i=0;i<3;i++){
      const y = 500 + i*100;
      const box = this.add.rectangle(panelX, y, 110, 110, 0xffffff).setStrokeStyle(6, 0x9fe2ff).setOrigin(0.5);
      this.upcomingSprites.push(box);
    }
    // Trash
    this.add.text(panelX, 820, 'TRASH', { font:'28px Arial', color:'#000' }).setOrigin(0.5);
    this.trashBox = this.add.rectangle(panelX, 900, 140, 120, 0xd9534f).setStrokeStyle(6, 0xffffff).setOrigin(0.5);
    this.trashText = this.add.text(panelX, 900, `x${this.trash}`, { font:'32px Arial', color:'#fff', fontStyle:'bold' }).setOrigin(0.5);

    // Create interactive zones for keep and trash
    this.keepZone = new Phaser.Geom.Rectangle(this.keepSlotBox.x - 55, this.keepSlotBox.y - 55, 110, 110);
    this.trashZone = new Phaser.Geom.Rectangle(this.trashBox.x - 70, this.trashBox.y - 60, 140, 120);

    // Fill initial queue
    this.queue = [ randomTileValue(this.level), randomTileValue(this.level), randomTileValue(this.level) ];
    this.renderQueue();

    // create draggable active tile as an image (top of queue)
    this.activeSprite = this.createTileSpriteFromValue(this.queue[0], W*0.65, H*0.57, true);

    // set input drag
    this.input.setDraggable(this.activeSprite);

    // keep rendering keepVal if exists
    this.keepSprite = null;
    if (this.keepVal !== null) this.renderKeep();

    // grid contents map (null or object {value, sprite})
    this.grid = new Array(16).fill(null);

    // input drag handlers
    this.input.on('dragstart', (pointer, obj) => {
      obj.setScale(1.08);
      obj.setDepth(20);
    });

    this.input.on('drag', (pointer, obj, dragX, dragY) => {
      obj.x = dragX; obj.y = dragY;
      if (obj.valueText) { obj.valueText.x = dragX; obj.valueText.y = dragY; }
    });

    this.input.on('dragend', (pointer, obj) => {
      obj.setScale(1.0);
      const dropped = this.handleDrop(pointer.worldX, pointer.worldY, obj);
      if (!dropped) {
        // snap back to original spot
        this.tweens.add({ targets: [obj, obj.valueText], x: obj.homeX, y: obj.homeY, duration: 220, ease:'Sine' });
      }
    });

    // click on upcoming top also to pick (for convenience)
    this.upcomingSprites[0].setInteractive().on('pointerdown', ()=> {
      // create a new active tile from queue[0] if active not being dragged
      if (!this.activeSprite || !this.activeSprite.input || !this.activeSprite.input.enabled) return;
    });

    // update HUD initial
    this.updateHUD();
  }

  // -------------------- Create visual tile object (returns container-like object) --------------------
  createTileSpriteFromValue(value, x, y, isActive=false) {
    // choose color asset by value deterministic mapping
    const colorKey = TILE_COLORS[value % TILE_COLORS.length];
    const imgKey = `tile_${colorKey}`;
    let sprite;
    if (this.textures.exists(imgKey)) {
      sprite = this.add.image(x, y, imgKey).setDisplaySize(110,110).setInteractive({ draggable: true });
    } else {
      // fallback colored rectangle
      const col = { blue:0x2da6ff, red:0xdf3f3f, purple:0x9b6aff, orange:0xff9b3b, pink:0xff6fb2 }[colorKey] || 0x2da6ff;
      sprite = this.add.rectangle(x, y, 110, 110, col).setStrokeStyle(4, 0x5fd7ff).setInteractive({ draggable: true });
    }
    sprite.value = value;
    sprite.homeX = x; sprite.homeY = y;
    sprite.setDepth(10);
    // number text
    sprite.valueText = this.add.text(x, y, String(value), { font:'30px Arial', color:'#042028', fontStyle:'bold' }).setOrigin(0.5);
    if (isActive) {
      // bigger/raised
      sprite.setScale(1.05);
      sprite.setDepth(30);
      sprite.valueText.setDepth(31);
    }
    return sprite;
  }

  // -------------------- Handle drop location logic --------------------
  handleDrop(wx, wy, obj) {
    // 1) Check if dropped on a grid slot
    for (let i=0;i<this.slotPositions.length;i++){
      const s = this.slotPositions[i];
      const dx = Math.abs(wx - s.x), dy = Math.abs(wy - s.y);
      if (dx <= 55 && dy <= 55) {
        // grid slot target
        return this.placeOnGrid(i, obj);
      }
    }
    // 2) Keep zone?
    if (Phaser.Geom.Rectangle.ContainsPoint(this.keepZone, new Phaser.Geom.Point(wx,wy))) {
      return this.dropOnKeep(obj);
    }
    // 3) Trash zone?
    if (Phaser.Geom.Rectangle.ContainsPoint(this.trashZone, new Phaser.Geom.Point(wx,wy))) {
      return this.dropOnTrash(obj);
    }
    return false;
  }

  // -------------------- Place tile into grid slot index --------------------
  placeOnGrid(slotIndex, obj) {
    // if occupied -> reject
    if (this.grid[slotIndex] !== null) {
      // Try merging if neighbor? Spec requires placing into empty slot only; we keep it strict: must drop on empty.
      // Snap back
      this.showFlash('Place on empty slot');
      return false;
    }

    const pos = this.slotPositions[slotIndex];
    // move sprite to slot
    this.tweens.add({ targets:[obj, obj.valueText], x: pos.x, y: pos.y, duration:200, ease:'Power2' });
    obj.homeX = pos.x; obj.homeY = pos.y;
    obj.x = pos.x; obj.y = pos.y;
    obj.valueText.x = pos.x; obj.valueText.y = pos.y;

    // register in grid
    this.grid[slotIndex] = { value: obj.value, sprite: obj };

    // remove active from scene and create marking? We'll keep sprite in grid
    // Now attempt to merge chain with neighbors
    this.processMergesAt(slotIndex).then(() => {
      // after merges finished, advance queue
      this.consumeActiveAndAdvance();
    });

    return true;
  }

  // -------------------- Process merging starting from a slot - returns Promise to wait for animations --------------------
  async processMergesAt(startIndex) {
    let changed = true;
    // Keep iterating while merges happen to handle chain reactions
    while (changed) {
      changed = false;
      // check adjacency of startIndex for possible merges with its neighbors
      // We'll scan whole grid for any possible adjacent merges, to handle chain scenario broadly
      for (let i=0;i<16;i++){
        if (!this.grid[i]) continue;
        const neighbors = this.getNeighborIndices(i);
        for (const n of neighbors) {
          if (!this.grid[n]) continue;
          const a = this.grid[i].value;
          const b = this.grid[n].value;
          // Rule 1: equal -> both disappear
          if (a === b) {
            // animate vanish both
            await this.animateVanishPair(i, n);
            this.grid[i] = null; this.grid[n] = null;
            changed = true;
            // increase score modestly
            this.addScore(5);
            break; // break neighbors loop to restart scanning
          }
          // Rule 2: divisible -> larger ÷ smaller is whole number, result replaces larger, smaller disappears
          let largerIndex = null, smallerIndex = null;
          if (a > b && a % b === 0) { largerIndex = i; smallerIndex = n; }
          else if (b > a && b % a === 0) { largerIndex = n; smallerIndex = i; }

          if (largerIndex !== null) {
            const largerVal = this.grid[largerIndex].value;
            const smallerVal = this.grid[smallerIndex].value;
            const result = largerVal / smallerVal;
            // animate transform: scale up larger, remove smaller
            await this.animateDivide(largerIndex, smallerIndex, result);
            // apply result (if result==1 remove the larger tile)
            if (result === 1) {
              // remove larger tile
              this.grid[largerIndex] = null;
            } else {
              // replace value and update text
              this.grid[largerIndex].value = result;
              const spr = this.grid[largerIndex].sprite;
              if (spr && spr.valueText) spr.valueText.setText(String(result));
            }
            // remove smaller
            this.grid[smallerIndex] = null;
            changed = true;
            // award points proportional to result (and base)
            this.addScore( POINTS_PER_DIVIDE_BASE + Math.floor(result*2) );
            break; // restart scanning
          }
        }
        if (changed) break;
      } // end scanning
    } // end while
    // after merges update HUD/best
    this.updateHUD();
    // small delay to allow final animations to finish visually
    await this.delay(120);
  }

  // -------------------- Helper: neighbor indices (4-directional) --------------------
  getNeighborIndices(index) {
    const r = Math.floor(index / 4), c = index % 4;
    const neighbors = [];
    if (r > 0) neighbors.push((r-1)*4 + c);
    if (c < 3) neighbors.push(r*4 + (c+1));
    if (r < 3) neighbors.push((r+1)*4 + c);
    if (c > 0) neighbors.push(r*4 + (c-1));
    return neighbors;
  }

  // -------------------- Animations for vanish pair --------------------
  animateVanishPair(i1, i2) {
    return new Promise(res => {
      const s1 = this.grid[i1].sprite, s2 = this.grid[i2].sprite;
      const t1 = s1.valueText, t2 = s2.valueText;
      this.tweens.add({ targets:[s1,t1], alpha:0, scale:0.1, duration:320, ease:'Power2' });
      this.tweens.add({ targets:[s2,t2], alpha:0, scale:0.1, duration:320, ease:'Power2', onComplete: ()=> {
        // destroy sprites
        s1.destroy(); t1.destroy(); s2.destroy(); t2.destroy();
        res();
      }});
    });
  }

  // -------------------- Animation and effect for divide --------------------
  animateDivide(largerIndex, smallerIndex, result) {
    return new Promise(res => {
      const larger = this.grid[largerIndex].sprite;
      const smaller = this.grid[smallerIndex].sprite;
      const largerText = larger.valueText;
      const smallerText = smaller.valueText;
      // pulse larger, fade smaller out and move smaller to larger then fade
      this.tweens.add({ targets: larger, scale:1.25, yoyo:true, duration:250 });
      this.tweens.add({ targets: largerText, scale:1.25, yoyo:true, duration:250 });
      this.tweens.add({ targets: smaller, x: larger.x, y: larger.y, duration:300, ease:'Power2' });
      this.tweens.add({ targets: smallerText, x: larger.x, y: larger.y, duration:300, ease:'Power2', onComplete: ()=> {
        // fade out smaller
        this.tweens.add({ targets:[smaller, smallerText], alpha:0, duration:220, onComplete: ()=>{
          smaller.destroy(); smallerText.destroy();
          // update larger text to result (do after a tiny delay)
          largerText.setText(String(result));
          res();
        }});
      }});
    });
  }

  // -------------------- Consume active tile and advance queue --------------------
  consumeActiveAndAdvance() {
    // remove active sprite (which is now placed and may have been destroyed by merges)
    if (this.activeSprite && this.activeSprite.active) {
      // If placed into grid, sprite remains in grid (not separate active sprite)
      // But if it's still active sprite object separate from grid (e.g., if placed into keep/trash), handle appropriately
      // We'll simply recreate activeSprite from queue[0] initially; after placement we shift queue and create new active sprite
    }
    // shift queue
    this.queue.shift();
    this.queue.push(randomTileValue(this.level));
    // destroy previous active visuals
    if (this.activeSprite) {
      // if sprite still exists but was placed into grid it should have been used; avoid double destroy
      // We will check if sprite is still in display list and remove it safely
      try { if (this.activeSprite.valueText) this.activeSprite.valueText.destroy(); } catch(e){}
      try { if (this.activeSprite.destroy) this.activeSprite.destroy(); } catch(e){}
    }
    // create new active sprite from new top
    const topX = this.scale.width*0.65, topY = this.scale.height*0.57;
    this.activeSprite = this.createTileSpriteFromValue(this.queue[0], topX, topY, true);
    this.input.setDraggable(this.activeSprite);
    this.renderQueue();
    // update HUD (already called in merge)
    this.updateHUD();
    // check game over condition
    if (this.isGameOver()) this.onGameOver();
  }

  // -------------------- Keep drop handling --------------------
  dropOnKeep(obj) {
    // If keepVal is null: store the active, remove from scene, advance queue
    if (this.keepVal === null) {
      this.keepVal = obj.value;
      // destroy active sprite (visual)
      if (obj.valueText) obj.valueText.destroy();
      if (obj.destroy) obj.destroy();
      this.activeSprite = null;
      // advance queue
      this.consumeActiveAndAdvance();
      this.renderKeep();
      this.showFlash('Stored in Keep');
      return true;
    } else {
      // swap: active <-> keepVal
      const oldKeep = this.keepVal;
      this.keepVal = obj.value;
      // destroy active visuals and create new active from oldKeep value (placed at same screen pos)
      if (obj.valueText) obj.valueText.destroy();
      if (obj.destroy) obj.destroy();
      // create active sprite from oldKeep at active location
      const topX = this.scale.width*0.65, topY = this.scale.height*0.57;
      this.activeSprite = this.createTileSpriteFromValue(oldKeep, topX, topY, true);
      this.input.setDraggable(this.activeSprite);
      this.renderKeep();
      this.showFlash('Swapped with Keep');
      return true;
    }
  }

  // -------------------- Trash drop handling --------------------
  dropOnTrash(obj) {
    if (this.trash <= 0) {
      this.showFlash('No trash left');
      return false;
    }
    // consume active tile (destroy)
    if (obj.valueText) obj.valueText.destroy();
    if (obj.destroy) obj.destroy();
    this.trash -= 1;
    this.trashText.setText(`x${this.trash}`);
    this.activeSprite = null;
    // advance queue
    this.consumeActiveAndAdvance();
    this.showFlash('Trashed');
    return true;
  }

  // -------------------- Render queue visuals --------------------
  renderQueue() {
    // update upcomingSprites with values
    for (let i=0;i<3;i++){
      const box = this.upcomingSprites[i];
      // remove old inner children (if any)
      if (box.tileSprite) {
        try { box.tileSprite.destroy(); } catch(e){}
        try { box.tileText.destroy(); } catch(e){}
      }
      const val = this.queue[i];
      // create visual centered on box
      const x = box.x, y = box.y;
      const sp = this.createTileSpriteFromValue(val, x, y, false);
      // smaller and behind
      sp.setScale(0.9);
      sp.setDepth(5);
      sp.valueText.setDepth(6);
      // store reference on box to destroy later
      box.tileSprite = sp;
      box.tileText = sp.valueText;
      // top one should be draggable? we'll use separate active sprite for drag
      if (i === 0) {
        // top indicator highlight
        box.setStrokeStyle(8, 0xffe0d6);
      } else {
        box.setStrokeStyle(6, 0x9fe2ff);
      }
    }
  }

  // -------------------- Render keep visual --------------------
  renderKeep() {
    if (this.keepSprite) {
      try{ this.keepSprite.destroy(); this.keepSprite.valueText.destroy(); } catch(e){}
      this.keepSprite = null;
    }
    if (this.keepVal !== null) {
      const x = this.keepSlotBox.x, y = this.keepSlotBox.y;
      const sp = this.createTileSpriteFromValue(this.keepVal, x, y, false);
      sp.setScale(0.92);
      sp.setDepth(7);
      // disable dragging for keep tile (drag must happen from active only)
      sp.disableInteractive();
      this.keepSprite = sp;
    }
  }

  // -------------------- Score / Level / HUD updates --------------------
  addScore(n) {
    this.score += n;
    // check level up
    const newLevel = Math.floor(this.score / LEVEL_SCORE_STEP) + 1;
    if (newLevel > this.level) {
      // level up
      this.level = newLevel;
      this.trash += 3; // reward trash uses on level up
      this.showFlash(`Level up! ${this.level}`);
    }
    if (this.score > this.best) {
      this.best = this.score;
      localStorage.setItem('jd_best', String(this.best));
    }
    this.updateHUD();
  }

  updateHUD() {
    if (this.levelText) this.levelText.setText(`LEVEL ${this.level}`);
    if (this.scoreText) this.scoreText.setText(`SCORE ${this.score}`);
    if (this.bestText) this.bestText.setText(`Best: ${this.best}`);
    if (this.trashText) this.trashText.setText(`x${this.trash}`);
  }

  // -------------------- Game over detection --------------------
  isGameOver() {
    // If any empty slot exists => not over
    for (let i=0;i<16;i++) if (this.grid[i] === null) return false;
    // grid full: check if any adjacent pair can merge
    for (let i=0;i<16;i++){
      const entry = this.grid[i];
      if (!entry) continue;
      const neigh = this.getNeighborIndices(i);
      for (const n of neigh) {
        if (!this.grid[n]) continue;
        const a = entry.value, b = this.grid[n].value;
        if (a === b) return false;
        if ((a > b && a % b === 0) || (b > a && b % a === 0)) return false;
      }
    }
    return true; // full and no merges
  }

  onGameOver() {
    // show overlay
    const W = this.scale.width, H = this.scale.height;
    const bg = this.add.rectangle(W/2, H/2, W*0.6, H*0.5, 0xffffff).setStrokeStyle(4, 0x222);
    const t = this.add.text(W/2, H/2 - 40, 'Game Over', { font:'40px Arial', color:'#222' }).setOrigin(0.5);
    const d = this.add.text(W/2, H/2 + 10, `Score: ${this.score}\nBest: ${this.best}`, { font:'26px Arial', color:'#555', align:'center' }).setOrigin(0.5);
    const btn = this.add.text(W/2, H/2 + 90, 'Restart', { font:'24px Arial', backgroundColor:'#4e85ff', color:'#fff', padding:{ x:12, y:8 } }).setOrigin(0.5).setInteractive();
    btn.on('pointerdown', ()=> {
      // restart scene
      this.scene.restart();
    });
  }

  // -------------------- Small utilities --------------------
  delay(ms) { return new Promise(res=> this.time.delayedCall(ms, res)); }

  showFlash(msg) {
    const W = this.scale.width;
    const f = this.add.text(W/2, 180, msg, { font:'26px Arial', color:'#222' }).setOrigin(0.5);
    this.tweens.add({ targets: f, alpha:0, duration:1400, delay:500, onComplete: ()=> f.destroy() });
  }
}

// --------------------------- Boot Phaser ---------------------------
const config = {
  type: Phaser.AUTO,
  parent: 'game-container',
  width: DESIGN.width,
  height: DESIGN.height,
  backgroundColor: '#f7f7f7',
  scale: { mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH },
  scene: [ BootScene, GameScene ]
};
const game = new Phaser.Game(config);
</script>
</body>
</html>
